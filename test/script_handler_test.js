// Generated by CoffeeScript 1.4.0
(function() {
  "use strict";
  var __slice = [].slice;

  describe('A script handler', function() {
    var emit, emitter, handler, onCommand, onEmit, onUnknown, script1, script2, sendMessage;
    script1 = script2 = handler = emitter = onEmit = void 0;
    sendMessage = function(script, event) {
      return handler._handleMessage({
        source: script.frame,
        data: event
      });
    };
    emit = function() {
      var args, channel, event, name, server, type;
      type = arguments[0], server = arguments[1], channel = arguments[2], name = arguments[3], args = 5 <= arguments.length ? __slice.call(arguments, 4) : [];
      event = (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(Event, [type, name].concat(__slice.call(args)), function(){});
      event.setContext(server, channel);
      return emitter.emit(type, event);
    };
    onCommand = jasmine.createSpy('onCommand');
    onUnknown = jasmine.createSpy('onUnknown');
    beforeEach(function() {
      var mockFrame1, mockFrame2;
      mockFrame1 = {
        postMessage: function() {}
      };
      mockFrame2 = {
        postMessage: function() {}
      };
      script1 = new window.script.Script('1', mockFrame1);
      script2 = new window.script.Script('2', mockFrame2);
      spyOn(script1, 'postMessage');
      spyOn(script2, 'postMessage');
      handler = new window.script.ScriptHandler();
      spyOn(handler, 'emit').andCallThrough();
      emitter = new EventEmitter;
      handler.addScript(script1);
      handler.addScript(script2);
      handler.addEventsFrom(emitter);
      onCommand.reset();
      return onUnknown.reset();
    });
    afterEach(function() {
      return handler.tearDown();
    });
    it("intercepts user commands that have been hooked", function() {
      sendMessage(script1, {
        type: 'hook_command',
        name: 'say'
      });
      emit('command', 'freenode', '#bash', 'say', 'hey', 'there!');
      return expect(handler.emit).not.toHaveBeenCalled();
    });
    it("doesn't intercepts user commands that cannot be intercepted", function() {
      sendMessage(script1, {
        type: 'hook_command',
        name: 'help'
      });
      emit('command', 'freenode', '#bash', 'help');
      return expect(handler.emit).toHaveBeenCalled();
    });
    it("intercepts server messages that have been hooked", function() {
      sendMessage(script1, {
        type: 'hook_server',
        name: 'joined'
      });
      emit('server', 'freenode', '', 'joined', '#bash');
      return expect(handler.emit).not.toHaveBeenCalled();
    });
    it("doesn't intercept events that haven't been hooked", function() {
      handler.on('command', onCommand);
      handler.on('unknown', onUnknown);
      emit('command', 'freenode', '#bash', 'say', 'hey', 'there!');
      emit('unknown');
      expect(onCommand).toHaveBeenCalled();
      return expect(onUnknown).toHaveBeenCalled();
    });
    it("sends an event when a hooked event is entered", function() {
      var event;
      sendMessage(script1, {
        type: 'hook_command',
        name: 'say'
      });
      emit('command', 'freenode', '#bash', 'say', 'hey', 'there!');
      event = script1.postMessage.mostRecentCall.args[0];
      expect(event.type).toBe('command');
      expect(event.context.server).toBe('freenode');
      expect(event.context.channel).toBe('#bash');
      expect(event.name).toBe('say');
      expect(event.args).toEqual(['hey', 'there!']);
      return expect(event.id).toEqual(jasmine.any(Number));
    });
    it("sends events only to the scripts that have hooked them", function() {
      sendMessage(script1, {
        type: 'hook_command',
        name: 'say'
      });
      emit('command', 'freenode', '#bash', 'say', 'hey', 'there!');
      expect(script1.postMessage).toHaveBeenCalled();
      return expect(script2.postMessage).not.toHaveBeenCalled();
    });
    it("forwards events only after receiving 'propagate: all' from all scripts", function() {
      var id1, id2;
      sendMessage(script1, {
        type: 'hook_command',
        name: 'say'
      });
      sendMessage(script2, {
        type: 'hook_command',
        name: 'say'
      });
      emit('command', 'freenode', '#bash', 'say', 'hey', 'there!');
      id1 = script1.postMessage.mostRecentCall.args[0].id;
      id2 = script2.postMessage.mostRecentCall.args[0].id;
      sendMessage(script1, {
        type: 'propagate',
        name: 'all',
        args: [id1]
      });
      expect(handler.emit).not.toHaveBeenCalled();
      sendMessage(script2, {
        type: 'propagate',
        name: 'all',
        args: [id2]
      });
      return expect(handler.emit).toHaveBeenCalled();
    });
    it("swallows events when received 'propagate: none' from at least one script", function() {
      var id1, id2;
      sendMessage(script1, {
        type: 'hook_command',
        name: 'say'
      });
      sendMessage(script2, {
        type: 'hook_command',
        name: 'say'
      });
      emit('command', 'freenode', '#bash', 'say', 'hey', 'there!');
      id1 = script1.postMessage.mostRecentCall.args[0].id;
      id2 = script2.postMessage.mostRecentCall.args[0].id;
      sendMessage(script1, {
        type: 'propagate',
        name: 'all',
        args: [id1]
      });
      expect(handler.emit).not.toHaveBeenCalled();
      sendMessage(script2, {
        type: 'propagate',
        name: 'none',
        args: [id2]
      });
      return expect(handler.emit).not.toHaveBeenCalled();
    });
    return it("sends 'command' when a registered command is entered", function() {
      sendMessage(script1, {
        type: 'command',
        context: {
          server: 'freenode',
          channel: '#bash'
        },
        name: 'say',
        args: ['hi', 'there!']
      });
      return expect(handler.emit).toHaveBeenCalled();
    });
  });

}).call(this);
